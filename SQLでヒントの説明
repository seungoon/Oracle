１．つけるべきヒント句は６種類だけ

　・テーブル結合に係る部分だけですね。
 
　ordered / leading
　inxex / full
　use_nl / use_hash
 
２．ordered / leading
orderedはSQLで書いたテーブル順に結合します。

leadingは指定したテーブル順に結合します。

要はテーブル結合の順序を切り替えるわけですね。

なぜ必要かというと、A, B のテーブルをinner joinする際、

Aが100万件

Bが1件

の場合、

A, B の順で結合しても

B, A の順で結合しても

1件ですが

A, B の順で結合すると→一旦100万件取得してから1件になる

B,A の順で結合すると→1件取得して100万件の中の1件をさがして結合

という差が出てくるそうです。

 

つまり、結合順序は数が少ないものを先にしていくことが

重要ということです。

leadingは本体のSQLを書き換えなくても順序だけ変えられるので

俺のせいじゃないといえるところも大好きです。

 

２．use_nl/use_hash/full/index
結合方法を指定するヒント句です。

use_nlはネステッドループ結合をさせます。

元テーブル１件読んで、結合テーブルを探してくっつけて、次レコードへ。

を繰り返します。

use_hashはハッシュ結合をさせます。

元テーブル読んで、結合テーブル読んで、一気に結合します。

 

fullはテーブル全件を読み込ませます。

indexは指定したインデックスを使ってテーブルを抽出します。

この４つについては私の中で使い方に鉄則があるのでまとめました。


３．鉄則
use_nl を使う場合、indexとセットで使う！
→この組み合わせは
主に同時アクセス数が多く
サーバ負荷を減らして実行させたい場合に使う。
オンライン処理とか。
あと、結合元１件に対して少量の結合の場合もこっち。
use_hashを使う場合、fullとセットで使う！
→この組み合わせは
主に同時アクセス数が少なく
負荷かかってもいいから早さを優先する場合に使う。
夜間バッチとか。
あと、結合元１件に対して全件（近い件数）の結合の場合はこっち。
use_nlを使うと取得結果を１件ずつ結合するイメージになります。

(Nested Loop結合）

内部的には何度も結合することになるのでindex検索しないとですね。

Nested LoopでFULLしちゃってる場合、取得レコードの掛け算分結合に

なるのでおそーくなるというわけです。

 

反対にuse_hashは一回読み込んだものをメモリ（ということにしておく）に

展開して一気に結合します。

この時リソースは消費しますが結合元・結合先の読み込みは１回、

あとはメモリ上でくっつけることになるので早くなります。
